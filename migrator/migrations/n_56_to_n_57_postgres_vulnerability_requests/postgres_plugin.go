// Code generated by pg-bindings generator. DO NOT EDIT.

package n56ton57

import (
	"context"

	"github.com/jackc/pgx/v4"
	"github.com/stackrox/rox/generated/storage"
	ops "github.com/stackrox/rox/pkg/metrics"
	"github.com/stackrox/rox/pkg/postgres/pgutils"
)

func (s *storeImpl) copyFromVulnerabilityRequests(ctx context.Context, tx pgx.Tx, objs ...*storage.VulnerabilityRequest) error {

	inputRows := [][]interface{}{}

	var err error

	// This is a copy so first we must delete the rows and re-add them
	// Which is essentially the desired behaviour of an upsert.
	var deletes []string

	copyCols := []string{

		"id",

		"targetstate",

		"status",

		"expired",

		"requestor_name",

		"createdat",

		"lastupdated",

		"deferralreq_expiry_expireswhenfixed",

		"deferralreq_expiry_expireson",

		"cves_ids",

		"serialized",
	}

	for idx, obj := range objs {
		// Todo: ROX-9499 Figure out how to more cleanly template around this issue.
		log.Debugf("This is here for now because there is an issue with pods_TerminatedInstances where the obj in the loop is not used as it only consists of the parent id and the idx.  Putting this here as a stop gap to simply use the object.  %s", obj)

		serialized, marshalErr := obj.Marshal()
		if marshalErr != nil {
			return marshalErr
		}

		inputRows = append(inputRows, []interface{}{

			obj.GetId(),

			obj.GetTargetState(),

			obj.GetStatus(),

			obj.GetExpired(),

			obj.GetRequestor().GetName(),

			pgutils.NilOrTime(obj.GetCreatedAt()),

			pgutils.NilOrTime(obj.GetLastUpdated()),

			obj.GetDeferralReq().GetExpiry().GetExpiresWhenFixed(),

			pgutils.NilOrTime(obj.GetDeferralReq().GetExpiry().GetExpiresOn()),

			obj.GetCves().GetIds(),

			serialized,
		})

		// Add the id to be deleted.
		deletes = append(deletes, obj.GetId())

		// if we hit our batch size we need to push the data
		if (idx+1)%batchSize == 0 || idx == len(objs)-1 {
			// copy does not upsert so have to delete first.  parent deletion cascades so only need to
			// delete for the top level parent

			if err := s.DeleteMany(ctx, deletes); err != nil {
				return err
			}
			// clear the inserts and vals for the next batch
			deletes = nil

			_, err = tx.CopyFrom(ctx, pgx.Identifier{"vulnerability_requests"}, copyCols, pgx.CopyFromRows(inputRows))

			if err != nil {
				return err
			}

			// clear the input rows for the next batch
			inputRows = inputRows[:0]
		}
	}

	for idx, obj := range objs {
		_ = idx // idx may or may not be used depending on how nested we are, so avoid compile-time errors.

		if err = s.copyFromVulnerabilityRequestsApprovers(ctx, tx, obj.GetId(), obj.GetApprovers()...); err != nil {
			return err
		}
		if err = s.copyFromVulnerabilityRequestsComments(ctx, tx, obj.GetId(), obj.GetComments()...); err != nil {
			return err
		}
	}

	return err
}

func (s *storeImpl) copyFromVulnerabilityRequestsApprovers(ctx context.Context, tx pgx.Tx, vulnerability_requests_Id string, objs ...*storage.SlimUser) error {

	inputRows := [][]interface{}{}

	var err error

	copyCols := []string{

		"vulnerability_requests_id",

		"idx",

		"name",
	}

	for idx, obj := range objs {
		// Todo: ROX-9499 Figure out how to more cleanly template around this issue.
		log.Debugf("This is here for now because there is an issue with pods_TerminatedInstances where the obj in the loop is not used as it only consists of the parent id and the idx.  Putting this here as a stop gap to simply use the object.  %s", obj)

		inputRows = append(inputRows, []interface{}{

			vulnerability_requests_Id,

			idx,

			obj.GetName(),
		})

		// if we hit our batch size we need to push the data
		if (idx+1)%batchSize == 0 || idx == len(objs)-1 {
			// copy does not upsert so have to delete first.  parent deletion cascades so only need to
			// delete for the top level parent

			_, err = tx.CopyFrom(ctx, pgx.Identifier{"vulnerability_requests_approvers"}, copyCols, pgx.CopyFromRows(inputRows))

			if err != nil {
				return err
			}

			// clear the input rows for the next batch
			inputRows = inputRows[:0]
		}
	}

	return err
}

func (s *storeImpl) copyFromVulnerabilityRequestsComments(ctx context.Context, tx pgx.Tx, vulnerability_requests_Id string, objs ...*storage.RequestComment) error {

	inputRows := [][]interface{}{}

	var err error

	copyCols := []string{

		"vulnerability_requests_id",

		"idx",

		"user_name",
	}

	for idx, obj := range objs {
		// Todo: ROX-9499 Figure out how to more cleanly template around this issue.
		log.Debugf("This is here for now because there is an issue with pods_TerminatedInstances where the obj in the loop is not used as it only consists of the parent id and the idx.  Putting this here as a stop gap to simply use the object.  %s", obj)

		inputRows = append(inputRows, []interface{}{

			vulnerability_requests_Id,

			idx,

			obj.GetUser().GetName(),
		})

		// if we hit our batch size we need to push the data
		if (idx+1)%batchSize == 0 || idx == len(objs)-1 {
			// copy does not upsert so have to delete first.  parent deletion cascades so only need to
			// delete for the top level parent

			_, err = tx.CopyFrom(ctx, pgx.Identifier{"vulnerability_requests_comments"}, copyCols, pgx.CopyFromRows(inputRows))

			if err != nil {
				return err
			}

			// clear the input rows for the next batch
			inputRows = inputRows[:0]
		}
	}

	return err
}

func (s *storeImpl) copyFrom(ctx context.Context, objs ...*storage.VulnerabilityRequest) error {
	conn, release, err := s.acquireConn(ctx, ops.Get, "VulnerabilityRequest")
	if err != nil {
		return err
	}
	defer release()

	tx, err := conn.Begin(ctx)
	if err != nil {
		return err
	}

	if err := s.copyFromVulnerabilityRequests(ctx, tx, objs...); err != nil {
		if err := tx.Rollback(ctx); err != nil {
			return err
		}
		return err
	}
	if err := tx.Commit(ctx); err != nil {
		return err
	}
	return nil
}
